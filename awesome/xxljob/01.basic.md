## basic

1. 初始化 admin 需要的数据库
2. 部署 xxl-job-admin
3. 部署执行器(应用程序)

   - 需要配置调度中心: `xxl.job.admin.address=http://xxl-job-admin:8080/xxl-job-admin`
   - 执行器集群: 使用 appName 做心跳 | 注册 | 分组 | 集群 依据

4. 在 admin 上创建执行器(appName)

   - AppName: 执行器集群的唯一标示 + 执行器会周期性以 AppName 为对象进行自动注册 + 供任务调度时使用
   - 自动注册: 执行器自动进行执行器注册, 调度中心通过底层注册表可以动态发现执行器机器地址
   - 手动录入: 人工手动录入执行器的地址信息, 多地址逗号分隔, 供调度中心使

   ![avatar](/static/image/xxljob-web-executor.png)

5. 在 admin 上创建任务

   - 执行器
   - 报警邮箱
   - 调度类型: 无(手动调度) | CRON | 固定速度 | _父子任务触发_
   - 运行模式: BEAN | GLUE
   - jobhandler: 执行器内的任务名称
   - 路由策略: 当执行器集群部署时, 提供丰富的路由策略

     1. first(第一个): 固定选择第一个机器
     2. last(最后一个): 固定选择最后一个机器
     3. round(轮询):
     4. random(随机): 随机选择在线的机器
     5. consistent_hash(一致性 hash): 每个任务按照 hash 算法固定选择某一台机器, 且所有任务均匀散列在不同机器上。
     6. least_frequently_used(最不经常使用): 使用频率最低的机器优先被选举
     7. least_recently_used(最近最久未使用): 最久未使用的机器优先被选举
     8. failover(故障转移): 按照顺序依次进行心跳检测, 第一个心跳检测成功的机器选定为目标执行器并发起调度
     9. busyover(忙碌转移): 按照顺序依次进行空闲检测, 第一个空闲检测成功的机器选定为目标执行器并发起调度
     10. sharding_broadcast(分片广播): 广播触发对应集群中所有机器执行一次任务, 同时系统自动传递分片参数 可根据分片参数开发分片任务

   - 调度过期策略:

     1. 忽略: 调度过期后, 忽略过期的任务, 从当前时间开始重新计算下次触发时间
     2. 立即执行一次: 调度过期后, 立即执行一次, 并从当前时间开始重新计算下次触发时间

   - 阻塞处理策略: 调度过于密集执行器来不及处理时的处理策略

     1. 单机串行(默认): 调度请求进入单机执行器后, 调度请求进入 FIFO 队列并以串行方式运行
     2. 丢弃后续调度: 调度请求进入单机执行器后, 发现执行器存在运行的调度任务, 本次请求将会被丢弃并标记为失败
     3. 覆盖之前调度: 调度请求进入单机执行器后, 发现执行器存在运行的调度任务, 将会终止运行中的调度任务并清空队列, 然后运行本地调度任务
     4. **因为 admin 只是单独的负责触发任务异步执行, 所以可能会导致第一个第一个 admin 触发到执行器 1 的任务没有被执行完, 此时 admin 再次触发并在执行器 2 上执行: 此时同一个任务可能会被同时执行到(解决[让任务幂等/永远触发到某台执行器/加锁标识任务状态/*增加 admin 调度间隔*])**

   - 子任务: 每个任务都拥有一个唯一的任务 ID(任务 ID 可以从任务列表获取), 当本任务执行结束并且执行成功时, 将会触发子任务 ID 所对应的任务的一次主动调度
   - 失败重试次
   - 任务超时时间: 超时后终止

6. 手动触发执行或等待执行

   - 调度中心触发任务: rpc
   - 执行器内执行
   - 执行完后回调调度中心执行结果

7. 查看相关执行 log
   - 可以清理日志

## notice

1. 任务超时时间 || 终止运行中的任务

   ```java
   // 任务终止时通过 interrupt 执行线程的方式实现, 将会触发 InterruptedException 异常
   // 因此如果 JobHandler 内部 catch 到了该异常并消化掉的话, 任务终止功能将不可用
   try{
     // do something
   } catch (Exception e) {
       if (e instanceof InterruptedException) {
           throw e;
       }
       logger.warn("{}", e);
   }
   ```

2. 为什么会有过期的任务

   - 服务重启
   - 调度线程被阻塞, 线程被耗尽
   - 上次调度持续阻塞, 下次调度被错过

3. 线程池隔离: 调度线程池进行隔离拆分, 慢任务自动降级进入"Slow"线程池, 避免耗尽调度线程, 提高系统稳定性

   - 单个任务每分钟内执行时间超过 500ms 十次则会自动进入 slow 执行
   - triggerPoolSlowMax 默认 100 + triggerPoolFastMax 默认 200

4. 任务调度的核心逻辑

   - 线程 scheduleThread 运行中不断的从任务表中查询 查询近 6000 毫秒(5 秒)中要执行的任务
   - 如果当前时间大于任务接下来要执行的时间则立即执行
   - 否则将任务执行时间除以 1000 变为秒之后再与 60 求余添加到时间轮中
   - pre-read count: threadpoolsize(200+100) \* trigger-qps(默认每个调度触发 50ms 则 20qps)

5. 调度的唯一性保证:(防止多个调度中心同时出发 1 个任务)

   - `select * from xxl_job_lock where lock_name = 'schedule_lock' for update`

6. 内部的调用(admin 触发 executor 执行): 是纯粹的 http 调用

## mysql

1. xxl_job_lock: 任务调度锁表
2. xxl_job_info: 调度扩展信息表, 用于保存 XXL-JOB 调度任务的扩展信息
   - 如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等
3. xxl_job_group: 执行器信息表, 维护任务执行器信息
4. xxl_job_registry: 执行器注册表, 维护在线的执行器和调度中心机器地址信息
5. xxl_job_log: 调度日志表, 用于保存 XXL-JOB 任务调度的历史信息
   - 如调度结果、执行结果、调度入参、调度机器和执行器等等
6. xxl_job_log_report: 调度日志报表, 用户存储 XXL-JOB 任务调度日志的报表, 调度中心报表功能页面会用到
7. xxl_job_logglue: 任务 GLUE 日志, 用于保存 GLUE 更新历史, 用于支持 GLUE 的版本回溯功能
8. xxl_job_user: 系统用户表
